# 数据结构和算法总结  
## 一、数组  
数组是存放在连续内存空间上的相同类型数据的集合  
(1)数组的下标都是从0开始的  
(2)数组内存空间的地址是连续的  
(3)数组元素是不能删除的，只能覆盖  
![](https://camo.githubusercontent.com/8553f690a09674acca02d88b29eeb07f8e866c4c570f5d9cb8ad6348d9b3a176/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f2545372541452539372545362542332539352545392538302539412545352538352542332545362539352542302545372542422538342e706e67)
(4)二维数组内存的空间地址在C++中是连续的，不同编程语言可能不同
*** 
### 二分法
*** 
#### leetcode704.二分查找  
>https://leetcode-cn.com/problems/binary-search/   
***  
```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size()-1; //左闭右闭区间
        while(left <= right)
        {
            int mid = left + (right - left)/2;
            if(nums[mid]==target) return mid;
            else if(target < nums[mid]) 
            {
                right = mid - 1;
            }
            else
            {
                left = mid + 1;
            }
        }
        return -1;
    }
};
```   
#### leet35.搜索插入位置  
>https://leetcode-cn.com/problems/search-insert-position/  
***  
```
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for(int i=0; i<nums.size(); ++i)
        {
            if(nums[i]>=target) return i;
        }
        return nums.size();
    }
};
```  
```
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; 
        while(left <= right)
        {
            int mid = left + (right - left)/2;
            if(target == nums[mid])
            {
                return mid;
            }
            else if(target < nums[mid])
            {
                right = mid - 1;
            }
            else
            {
                left = mid + 1;
            }
        }
        return right + 1;
    }
};
```   
#### leetcode 34.排序数组中查找元素中第一个和最后一个位置  
>https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/  
***  
![](https://pic.leetcode-cn.com/1617453327-bzDAuB-image.png)
***  
```
class Solution {
    int leftBound(const vector<int>& nums, int target)
    {
        int left = 0, right = nums.size()-1;
        while(left<right)
        {
            int mid = left + (right-left)/2;
            if(nums[mid]>=target)
            {
                right = mid;
            }
            else
            {
                left = mid + 1;
            }
        }
        if(nums[left]==target) return left;
        else return -1;
    }
    int rightBound(const vector<int>& nums, int target)
    {
        int left = 0, right = nums.size()-1;
        while(left<right)
        {
            int mid = left + (right-left+1)/2;
            if(nums[mid]<=target)
            {
                left = mid;
            }
            else
            {
                right = mid - 1;
            }
        }
        if(nums[right]==target) return right;
        else return -1;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size()==0) return {-1,-1};
        int left_b = leftBound(nums,target);
        int right_b = rightBound(nums,target);
        return {left_b,right_b};
    }
};
```
