# 数据结构和算法总结  
## 一、数组  
数组是存放在连续内存空间上的相同类型数据的集合  
(1)数组的下标都是从0开始的  
(2)数组内存空间的地址是连续的  
(3)数组元素是不能删除的，只能覆盖  
![](https://camo.githubusercontent.com/8553f690a09674acca02d88b29eeb07f8e866c4c570f5d9cb8ad6348d9b3a176/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f2545372541452539372545362542332539352545392538302539412545352538352542332545362539352542302545372542422538342e706e67)
(4)二维数组内存的空间地址在C++中是连续的，不同编程语言可能不同
*** 
### 二分法
*** 
#### leetcode704.二分查找  
>https://leetcode-cn.com/problems/binary-search/   
***  
```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size()-1; //左闭右闭区间
        while(left <= right)
        {
            int mid = left + (right - left)/2;
            if(nums[mid]==target) return mid;
            else if(target < nums[mid]) 
            {
                right = mid - 1;
            }
            else
            {
                left = mid + 1;
            }
        }
        return -1;
    }
};
```   
#### leet35.搜索插入位置  
>https://leetcode-cn.com/problems/search-insert-position/  
***  
```
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for(int i=0; i<nums.size(); ++i)
        {
            if(nums[i]>=target) return i;
        }
        return nums.size();
    }
};
```  
```
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; 
        while(left <= right)
        {
            int mid = left + (right - left)/2;
            if(target == nums[mid])
            {
                return mid;
            }
            else if(target < nums[mid])
            {
                right = mid - 1;
            }
            else
            {
                left = mid + 1;
            }
        }
        return right + 1;
    }
};
```   
#### leetcode 34.排序数组中查找元素中第一个和最后一个位置  
>https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/  
***  
![](https://pic.leetcode-cn.com/1617453327-bzDAuB-image.png)
***  
```
class Solution {
    int leftBound(const vector<int>& nums, int target)
    {
        int left = 0, right = nums.size()-1;
        while(left<right)
        {
            int mid = left + (right-left)/2;
            if(nums[mid]>=target)
            {
                right = mid;
            }
            else
            {
                left = mid + 1;
            }
        }
        if(nums[left]==target) return left;
        else return -1;
    }
    int rightBound(const vector<int>& nums, int target)
    {
        int left = 0, right = nums.size()-1;
        while(left<right)
        {
            int mid = left + (right-left+1)/2;
            if(nums[mid]<=target)
            {
                left = mid;
            }
            else
            {
                right = mid - 1;
            }
        }
        if(nums[right]==target) return right;
        else return -1;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size()==0) return {-1,-1};
        int left_b = leftBound(nums,target);
        int right_b = rightBound(nums,target);
        return {left_b,right_b};
    }
};
```   
#### leetcode.69 x的平方根  
>https://leetcode-cn.com/problems/sqrtx/  
***  
```
public:
    int mySqrt(int x) {
       int left = 0;
       int right = x;
       while(left<=right)
       {
           int mid = left + (right-left)/2;
           if((long long)mid*mid == x) return mid;
           else if((long long)mid*mid < x) left = mid + 1;
           else right = mid - 1;
       }
       return right;
    }
};
```  
#### leetcode.367 有效的完全平方数  
>https://leetcode-cn.com/problems/valid-perfect-square/  
***  
```
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 1, right = num;
        while(left <= right)
        {
            int mid = left + (right-left)/2;
            int div = num/mid;
            int mod = num%mid;
            if(div == mid && mod == 0) return true;
            else if(div < mid) //mid*mid >num
            {
                right = mid - 1;
            }
            else if(div > mid || (div==mid && mod != 0)) //mid*mid < num
            {
                left = mid + 1;
            }
        }
        return false;
    }
};
```  
### 快慢指针  
#### leetcode 27.移除元素  
>https://leetcode-cn.com/problems/remove-element/  
*** 
```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for(int fastIndex = 0; fastIndex < nums.size(); ++fastIndex)
        {
            if(nums[fastIndex]!=val)
            {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```   
#### leetcode 26.删除有序数组中的重复项  
>https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 
***  
```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int slow = 1;
        for(int i=1; i<nums.size(); ++i)
        {
            if(nums[i]!=nums[i-1])
            {
                nums[slow++] = nums[i];
            }
        }
        return slow;
    }
};
```  
#### leetcode 844.比较含退格的字符串  
>https://leetcode-cn.com/problems/backspace-string-compare/  
***  
```
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int i = s.length()-1,j = t.length() - 1;
        int skipS = 0, skipT = 0;
        while(i>=0 || j>=0)
        {
            while(i>=0)
            {
                if(s[i]=='#')
                {
                    i--;
                    skipS++;
                }
                else if(skipS>0)
                {
                    i--;
                    skipS--;
                }
                else
                {
                    break;
                }
            }
            while(j>=0)
            {
                if(t[j]=='#')
                {
                    j--;
                    skipT++;
                }
                else if(skipT>0)
                {
                    j--;
                    skipT--;
                }
                else  
                {
                    break;
                }
            }
            if(i>=0 && j>=0)
            {
                if(s[i]!=t[j])
                {
                    return false;
                }
            }
            else 
            {
                if(i>=0 || j>=0)
                {
                    return false;
                }
            }
            i--;
            j--;
        }
        return true;
    }
};
```   
#### leetcode 977.有序数组的平方  
>https://leetcode-cn.com/problems/squares-of-a-sorted-array/  
***  
```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int left = 0, right = nums.size()-1;
        int k = nums.size()-1;
        vector<int> ans(nums.size());
        while(left <= right)
        {
            int leftValue = nums[left]*nums[left],rightValue = nums[right]*nums[right];
            if(leftValue > rightValue)
            {
                ans[k--] = leftValue;
                left++; 
            }
            else
            {
                ans[k--] = rightValue;
                right--;
            }
        }
        return ans;
    }
};
```   
### 滑动窗口  
#### 209.长度最小子数组  
>https://leetcode-cn.com/problems/minimum-size-subarray-sum/  
***  
```
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT_MAX;
        int left = 0, right = 0;
        int sum = 0;
        while(right<nums.size())
        {
            sum += nums[right];
            while(sum >= target)
            {
                if(right-left+1<res)
                {
                    res = right - left + 1;
                }
                sum -= nums[left++];
            }
            right++;
        }

        return res==INT_MAX? 0 : res;
    }
};
```  
#### 904.水果成篮  
>https://leetcode-cn.com/problems/fruit-into-baskets/  
***  
```
class Solution {
public:
    int totalFruit(vector<int>& nums) {
        if(nums.size()<=2) return nums.size();
        unordered_map<int,int> umap;
        int left=0, right = 0;
        int res = 0;
        while(right < nums.size())
        {
            umap[nums[right]]++;
            while(umap.size()>2)
            {
                umap[nums[left]]--;
                if(umap[nums[left]]==0)
                {
                    umap.erase(nums[left]);
                }
                left++;
            }
            if(right-left+1>res && umap.size()<=2)
            {
                res = right - left + 1;
            }
            right++;
        }
        return res;
    }
};
```  
#### 76.最小覆盖子串  
>https://leetcode-cn.com/problems/minimum-window-substring/  
***
解法一(超时)
```
class Solution {
    bool isin(const string &s, const string &t)
    {
        unordered_map<char,int> umap;
        for(auto ch:s)
        {
            umap[ch]++;
        }
        for(auto ch:t)
        {
            umap[ch]--;
            if(umap[ch]<0) return false;
        }
        return true;
    }
public:
    string minWindow(string s, string t) {
        if(s.size()<t.size()) return "";
        int left = 0, right = 0;
        string res;
        int len = s.size();
        while(right < s.length())
        {
            while(isin(s.substr(left,right-left+1),t))
            {
                if(right-left+1 <= len)
                {
                    res = s.substr(left,right-left+1);
                    len = right-left+1;
                }
                left++;
            }
            right++;
        }
        return res;
    }
};
```  
解法二：  
```
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> map;
        for (auto c : t) map[c]++;
        int left = 0, cnt = 0, maxlen = s.size() + 1, start = left;
        for (int i = 0; i < s.size(); ++i) {
            if(--map[s[i]]>=0)
            {
                ++cnt;
            }
            while(cnt == t.size()) {
                if (maxlen > i - left + 1) {
                    maxlen = i - left + 1;
                    start = left;
                } 
                if (++map[s[left]] > 0) 
                {
                    cnt--;
                }
                left++;
            }
        }
        return maxlen == s.size() + 1 ? "" : s.substr(start, maxlen);
    }
};
```

