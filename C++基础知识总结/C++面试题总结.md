## 1.C和C++的区别  
- C是面向过程的语言，是一个结构化的语言，考虑如何通过一个过程对输入进行处理得到输出；C++是面向对象的语言，主要特征是“封装、继承和多态”。封装隐藏了实现细节，使得代码模块化；派生类可以继承父类的数据和方法，扩展了已经存在的模块，实现了代码重用；多态则是“一个接口，多种实现”，通过派生类重写父类的虚函数，实现了接口的重用。
- C和C++动态管理内存的方法不一样，C是使用malloc/free，而C++除此之外还有new/delete关键字。
- C++支持函数重载，C不支持函数重载
- C++中有引用，C中不存在引用的概念
***  
## 2、#include<file.h> #include "file.h" 有什么区别?  
前者是从标准库路径寻找，后者是从当前工作路径
***  
## 3、C++文件编译与执行的四个阶段?  
- 预处理：根据文件中的预处理指令来修改源文件的内容
- 编译：编译成汇编代码
- 汇编：把汇编代码翻译成目标机器指令
- 链接：链接目标代码生成可执行程序   
***  
## 4、堆和栈有什么区别?  
- 栈存放函数的参数值、局部变量，由编译器自动分配释放
- 是由new分配的内存块，由应用程序控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收  
- 因为堆的分配需要使用频繁的new/delete，造成内存空间的不连续，会有大量的碎片
- 堆的生长空间向上，地址越大，栈的生长空间向下，地址越小  
***  
## 5、深拷贝和浅拷贝的区别 ?  
- 深拷贝和浅拷贝可以简单的理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝  
- 关键标志：有没有重新分配内存    
## 6、哪些成员函数不能被继承?
C++中，并不是所有的成员函数都能被子类继承，有三类成员函数不能被子类继承，分别是：构造函数（包括拷贝构造）、析构函数、赋值运算符重载函数。  
### 构造函数
- 构造方法用来初始化类的对象，与父类的其它成员不同，它不能被子类继承（子类可以继承父类所有的成员变量和成员方法，但不继承父类的构造方法）。因此，在创建子类对象时，为了初始化从父类继承来的数据成员，系统需要调用其父类的构造方法。
- 如果没有显式的构造函数，编译器会给一个默认的构造函数，并且该默认的构造函数仅仅在没有显式地声明构造函数情况下创建。 构造原则如下：
(1)如果子类没有定义构造方法，则调用父类的无参数的构造方法
(2)如果子类定义了构造方法，不论是无参数还是带参数，在创建子类的对象的时候,首先执行父类无参数的构造方法，然后执行自己的构造方法。
(3)在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数，则会调用父类的默认无参构造函数。
(4)在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类自己提供了无参构造函数，则会调用父类自己的无参构造函数
(5)在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类只定义了自己的有参构造函数，则会出错（如果父类只有有参数的构造方法，则子类必须显示调用此带参构造方法）
(6)如果子类调用父类带参数的构造方法，需要用初始化父类成员对象的方式 
总结：
(1)**构造函数和类同名，父类和子类不同名，父类构造函数放在子类里面毫无意义**  
(2)**子类继承来的数据成员和方法都是可以通过子类对象调用的，构造函数是用来创建对象的，继承父类的构造函数，想要调用继承而来的构造函数需要实例化子类，但如果不能成功调用构造函数，就不可能实例化子类**  
(3)**如果可以继承构造函数，子类新增的成员变量如何初始化？**

### 析构函数  
析构函数也不会被子类继承，只是在子类的析构函数中会调用父类的析构函数  
### 赋值运算符重载函数  
赋值运算符重载函数也不会被子类继承，只是在子类的赋值运算符重载函数中会调用父类的赋值运算符重载函数
***  
## 7、基类的析构函数为什么要用virtual虚析构函数?   
>https://blog.csdn.net/iicy266/article/details/11906457  
- 防止内存泄露，delete p（基类）的时候，它很机智的先执行了派生类的析构函数，然后执行了基类的析构函数
- 如果基类的析构函数不是虚函数，在delete p（基类）时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。  
***  
## 8、哪些函数不能声明成虚函数?  
**非成员函数、构造函数、静态成员函数、内联成员函数（可以但没效果）、友元函数**  
### 非成员函数
- 非成员函数只能被重载(overload)，不能被继承(override)，而虚函数主要的作用是在继承中实现动态多态，非成员函数早在编译期间就已经绑定函数了，无法实现动态多态，那声明成虚函数还有什么意义呢？   
### 构造函数
- 要想调用虚函数必须要通过vptr来进行的，vptr是要调用构造函数生成的，如果构造函数是虚函数，那么如何调用构造函数？    
### 静态成员函数
- static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。
**静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。**
虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual.虚函数的调用关系：this -> vptr -> vtable ->virtual function  
### 内联函数
- 内联函数是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，并且inline函数在编译时被展开，虚函数在运行时才能动态地绑定函数   
### 友元函数
- 因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。友元函数不属于类的成员函数，不能被继承   
***
## 9、多态，虚函数，纯虚函数?   
### 多态  
是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面
- 在程序运行时的多态性通过继承和虚函数来体现
- 在程序编译时多态性体现在函数和运算符的重载上  
### 虚函数  
在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。  
### 纯虚函数
- 在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用
- 从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类
- 抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性  
***  
## 10、如何初始化const和static数据成员?
- 通常在类外初始化static数据成员，但是 static const 的整型(bool，char，int，long)可以再类声明中初始化，static const的其他类型也必须在类外初始化(包括整型的数组)
- const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间
- static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中
- 在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate = 2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static
- 在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数
- const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。
- const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cosnt  
***  
## 11、关键字static有什么作用?  
- 函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值
- 模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内
- 类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝
- 类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量  
***  
## 12、#define和const有什么区别?  
- #define定义的常量没有类型，所给出的是一个立即数；const定义的常量有类型名字，存放在静态区域
- 处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝
- #define定义的常量是不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址
- #define可以定义简单的函数，const不可以定义函数  
***  
## 13、const 的作用?  
- 定义只读变量，即常量 
- 修饰函数的参数和函数的返回值 
- 修饰函数的定义体，这里的函数为类的成员函数，被const修饰的成员函数代表不修改成员变量的值
***  
## 14、结构体struct和共同体union（联合）的区别 ?
结构体：将不同类型的数据组合成一个整体，是自定义类型;  共同体：不同类型的几个变量共同占用一段内存
- 结构体中的每个成员都有自己独立的地址，它们是同时存在的； 共同体中的所有成员占用同一段内存，它们不能同时存在；
- sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度  
## 15、数组和指针有什么区别?  
数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块
- 指针没有[]运算符  
-  用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针  
***
## 16、指针和引用的区别?  
- 引用是变量的一个别名，内部实现是只读指针
- 引用只能在初始化时被赋值，其他时候值不能被改变，指针的值可以在任何时候被改变
- 引用不能为NULL，指针可以为NULL
- 引用变量内存单元保存的是被引用变量的地址
- “sizeof 引用" = 指向变量的大小 ， "sizeof 指针"= 指针本身的大小
- 引用可以取地址操作，返回的是被引用变量本身所在的内存单元地址
- 引用使用在源代码级相当于普通的变量一样使用，做函数参数时，内部传递的实际是变量地址
- 指针是对象，引用只是个别名
- 引用只有一级，指针可以有多级
- 指针传参的时候，还是值传递，指针本身的值不可以修改，需要通过解引用才能对指向的对象进行操作 引用传参的时候，传进来的就是变量本身，因此变量可以被修改  
***
## 17、delete与 delete []区别?  
- delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套  
- 对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。  
***  
## 18、new、delete、malloc、free关系? 
delete会调用对象的析构函数，new调用构造函数。malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。  
***  
## 19、简单介绍vector内存分配方式?  
先申请一定的大小的数组, 当数组填满之后,另外申请一块原数组两倍大的新数组, 然后把原数组的数据拷贝到新数组, 最后释放原数组的大小。 
*** 
## 20、STL里有哪些map?  
>https://blog.csdn.net/liumou111/article/details/49252645
### map  
内部数据的组织，基于红黑树实现，红黑树具有自动排序的功能，因此map内部所有的数据，在任何时候，都是有序的。  
### unordered_map  
C++ 11标准中加入了unordered系列的容器。unordered_map记录元素的hash值，根据hash值判断元素是否相同。map相当于java中的TreeMap，unordered_map相当于HashMap。无论从查找、插入上来说，unordered_map的效率都优于hash_map，更优于map；而空间复杂度方面，hash_map最低，unordered_map次之，map最大。对于STL里的map容器，count方法与find方法，都可以用来判断一个key是否出现，count统计的是key出现的次数，因此只能为0/1，而find基于迭代器实现，以mp.end()判断是否找到要求的key  
    
## 21、STL是如何进行内存管理的?   
>https://www.cnblogs.com/lang5230/p/5556611.html 
*** 
### 六大组件简单介绍  
#### (1)空间配置器  
内存池实现小块内存分配,对应到设计模式--单例模式（工具类，提供服务，一个程序只需要一个空间配置器即可），享元模式（小块内存统一由内存池进行管理）  
#### (2)迭代器  
迭代器模式，模板方法  
#### (3)容器  
STL的核心之一，其他组件围绕容器进行工作：迭代器提供访问方式，空间配置器提供容器内存分配，算法对容器中数据进行处理，仿函数伪算法提供具体的策略，类型萃取实现对自定义类型内部类型提取。保证算法覆盖性。其中涉及到的设计模式：组合模式（树形结构），门面模式（外部接口提供），适配器模式（stack，queue通过deque适配得到），建造者模式（不同类型树的建立过程）
#### (4)类型萃取  
基于范型编程的内部类型解析，通过typename获取。可以获取迭代器内部类型value_type,Pointer,Reference等 
#### (5)仿函数  
一种类似于函数指针的可回调机制，用于算法中的决策处理。涉及：策略模式，模板方法。
#### (6)适配器
STL中的stack，queue通过双端队列deque适配实现，map，set通过RB-Tree适配实现。涉及适配器模式
***  
![](https://images2015.cnblogs.com/blog/835234/201606/835234-20160603175828836-981621890.png)
### STL空间配置器产生的缘由  
#### (1)碎片产生原因  
在软件开发，程序设计中，我们不免因为程序需求，使用很多的小块内存（基本类型以及小内存的自定义类型）。在程序中动态申请，释放。这个过程并不好控制，可能会产生问题：
**问题1：就出现了内存碎片问题。（ps外碎片问题）**
**问题2：一直在因为小块内存而进行内存申请，调用malloc，系统调用产生性能问题。**
tips:
内碎片：因为内存对齐/访问效率（CPU取址次数）而产生如用户需要3字节，实际得到4或者8字节的问题，其中的碎片是浪费掉的
外碎片：系统中内存总量足够，但是不连续，所以无法分配给用户使用而产生的浪费。下边简单图解  
![](https://images2015.cnblogs.com/blog/835234/201606/835234-20160603183043711-1218867597.png)
#### (2)STL空间配置器实现策略  
用户申请空间大于128？
yes：调用一级空间配置器
no：调用二级空间配置器
*** 
具体实现： 
二级空间配置由内存池以及伙伴系统：自由链表组成
一级空间配置器直接封装malloc，free进行处理，增加了C++中的set_handler机制（这里其实也就是个略显牵强的装饰/适配模式了），增加内存分配时客户端可选处理机制。
***  
可配置性：
客户端可以通过宏__USE_MALLOC进行自定义选择是否使用二级空间配置器。一级空间配置器就主要封装malloc，添加handler机制了，这里就不罗嗦了，相信各位都是可以通过源码了解到的  
#### (3)二级空间配置器  
![](https://images2015.cnblogs.com/blog/835234/201606/835234-20160603190242711-522328255.png)
***
### 空间配置器的一些问题  
#### 二级空间配置器空间释放问题  
程序中不曾释放，只是在自由链表中，且配置器的所有方法，成员都是静态的，那么他们就是存放在静态区。释放时机就是程序结束
***  
#### 效率问题  
用户只需要无限的char类型空间，然而配置器中却对齐到8，于是乎，整个程序中就会有7/8的空间浪费。
对于假定用户申请N次8空间，将系统资源耗到一定程度，然后全部释放了，自由链表中的空间都是连续的。却没有释放。这个问题就是，空间可能全部积攒在小块自由链表中，却没有用户可用的。这就尴尬了  
***  
## 22、红黑树的特性与其在C++ STL中的应用 ?  
map 、set、multiset、multimap的底层实现都是红黑树，epoll模型的底层数据结构也是红黑树，linux系统中CFS进程调度算法，也用到红黑树  
(1)根结点是黑色的  
(2)不能有两个连续的红节点  
(3)空指针是黑色的  
(4)从任意节点出发，到后代中空指针的路径上，均包含相同数量的黑色节点  
***
## 23、STL中map和set的原理（关联式容器）?  
底层实现是红黑树，红黑树是一种特殊的二叉查找树   
红黑树的一些特点：
- 每个节点或者是黑色，或者是红色
- 根节点是黑色
- 每个叶子节点（NIL）是黑色。这里叶子节点，是指为空(NIL或NULL)的叶子节点
- 如果一个节点是红色的，则它的子节点必须是黑色的
- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点
- 决定了没有一条路径会比其他路径长出2倍，因此红黑树是接近平衡的二叉树。 
*** 
## 24、STL中unordered_map和map的区别 ?  
map是STL中的一个关联容器，提供键值对的数据管理。底层通过红黑树来实现，实际上是二叉排序树和非严格意义上的二叉平衡树。所以在map内部所有的数据都是有序的，且map的查询、插入、删除操作的时间复杂度都是O(logN)
unordered_map和map类似，都是存储key-value对，可以通过key快速索引到value，不同的是unordered_map不会根据key进行排序。unordered_map底层是一个防冗余的哈希表，存储时根据key的hash值判断元素是否相同，即unoredered_map内部是无序的  
***
## 25、STL中的vector的实现，是怎么扩容的?  
vector就是一个动态增长的数组，里面有一个指针指向一片连续的空间，当空间装不下的时候，会申请一片更大的空间，将原来的数据拷贝过去，并释放原来的旧空间。当删除的时候空间并不会被释放，只是清空了里面的数据。对比array是静态空间一旦配置了就不能改变大小。  
vector的动态增加大小的时候，并不是在原有的空间上持续新的空间（无法保证原空间的后面还有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，并释放原空间。在VS下是1.5倍扩容，在GCC下是2倍扩容
在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。  
***  
## 26、简单介绍一下STL库的容器和算法?
容器即存放数据的地方，比如array, vector，分为两类，序列式容器和关联式容器  
### 序列式容器  
其中的元素不一定有序，但是都可以被排序，比如vector,list,queue,stack，heap, priority-queue, slist  
### 关联式容器  
内部结构是一个平衡二叉树，每个元素都有一个键值和一个实值，比如map, set, hashtable, hash_set  
### 迭代器  
迭代器是STL的精髓，迭代器提供了一种方法，使得它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构，它将容器和算法分开，让二者独立设计  
***  
## 27、vector和list的区别?   
### vector  
vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
因此能高效的进行随机存取，时间复杂度为o(1);
但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝  
***  
### list  
list是由双向链表实现的，因此内存空间是不连续的。
只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);
但由于链表的特点，能高效地进行插入和删除。  
***  
## 28、解释静态绑定和动态绑定?  
1）对象的静态类型和动态类型
静态类型：对象在声明时采用的类型，在编译时确定
动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改 
2）静态绑定和动态绑定
静态绑定：绑定的是对象的静态类型，函数依赖于对象的静态类型，在编译期确定
动态绑定：绑定的是对象的动态类型，函数依赖于对象的动态类型，在运行期确定
只有虚函数才使用的是动态绑定，其他的全部是静态绑定   
***  
## 29、进程间通信方式和线程间通信方式 ?  
### 进程间通信  
#### 管道
管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系 
#### 信号量  
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。  
#### 消息队列  
消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点  
#### 共享内存  
共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信  
#### 套接字  
套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。
***  
### 线程间通信方式  
#### 全局变量  
#### Messages消息机制  
#### CEvent对象(MFC)  
***   
## 30、描述内存分配方式以及它们的区别?  
- 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量
- 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。
- 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。

















